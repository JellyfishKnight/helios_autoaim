// created by liuhan on 2023/9/15
// Submodule of HeliosRobotSystem
// for more see document: https://swjtuhelios.feishu.cn/docx/MfCsdfRxkoYk3oxWaazcfUpTnih?from=from_copylink
#pragma once

// ros
#include "rclcpp/rclcpp.hpp"
#include "tf2/convert.h"
#include "geometry_msgs/msg/transform_stamped.hpp"
#include "tf2_ros/buffer.h"
// custom
#include "BasePredictor.hpp"
#include "KalmanFilter.hpp"
#include "PnPSolver.hpp"
#include "Omega.hpp"
// opencv
#include"opencv2/imgproc.hpp"
#include"opencv2/highgui.hpp"
#include"opencv2/core.hpp"
// eigen 
#include"eigen3/Eigen/Core"
#include"eigen3/Eigen/Dense"
#include"eigen3/Eigen/Geometry"
// ceres-solver
#include"ceres/ceres.h"
#include"ceres/problem.h"

#define INIT 1
#define STANDBY 2
#define ESTIMATE 3
#define PREDICT 4
#define BIG_ENERGY 2
#define SMALL_ENRGY 1
#define AUTOAIM 0

// auto generated by ros2 generate_parameter_library
// https://github.com/PickNikRobotics/generate_parameter_library
#include "helios_autoaim_parameters.hpp"
#include <opencv2/core/types.hpp>

namespace helios_cv {

/*
 *   设置代价函数  用于优化
 */
struct SinResidual{
    SinResidual(double t, double omega): omega_(omega), t_(t) {}

    template<class T>
    bool operator()(const T* const a, const T* const w, const T* phi, T* residual) const {
        residual[0] = omega_ - (a[0] * sin(w[0] * t_ + phi[0]) + 2.09 - a[0]);
        return true;
    }
private:
    const double omega_;
    const double t_;
};

class EnergyPredictor : public BasePredictor {
public:
    EnergyPredictor(helios_autoaim::Params::Predictor::EnergyPredictor predictor_params);
    
    void set_cam_info(sensor_msgs::msg::CameraInfo::SharedPtr cam_info) override;

    void init_predictor(helios_autoaim::Params::Predictor predictor_param, tf2_ros::Buffer::SharedPtr tf_buffer) override;

    helios_rs_interfaces::msg::Target predict_target(helios_rs_interfaces::msg::Armors armors, const rclcpp::Time& now) override;

    void set_params(helios_autoaim::Params::Predictor predictor_params) override;

    std::vector<double> get_state() const override;
    void energy_refresh();

    /**
     * @brief 用ceres进行最小二乘拟合
     * 
    */
    void estimateParam(Omega &omega, bool isSolve);
    Omega omega_;
    bool isSolve_;
private:
    helios_autoaim::Params::Predictor::EnergyPredictor predictor_params_;
    tf2_ros::Buffer::SharedPtr tf_buffer_;

    sensor_msgs::msg::CameraInfo::SharedPtr cam_info_;
    cv::Point2f cam_center_;
    std::shared_ptr<PnPSolver> pnp_solver_;

    /**
     * @brief 预测主函数
    */
    void energy_predict(uint8_t mode, std::vector<cv::Point2f> &energy_points, cv::Point2f &center);


    /**
     * @brief 滤波器滤波角速度
    */
    void FilterOmega(float &dt);

    /**
     * @brief 有限状态机
    */
    bool EnergyStateSwitch();


    /**
     * @brief 计算预测后的点
    */
    cv::Point2f calPredict(cv::Point2f &p, cv::Point2f &center, float theta)const;

    void getPredictRect(cv::Point2f &center, std::vector<cv::Point2f> &pts, float theta);

    
    ceres::Problem problem;


    //转速相关
    uint8_t mode_;
    uint8_t circle_mode_;
    float total_theta_;

    int ceres_cnt_;

    cv::Point2f last_point_;//上一个装甲板中心点
    cv::Point2f predict_center_;//预测的中心点
    std::vector<cv::Point2f> predict_point_;//预测的装甲板四个点
    float predict_rad_ ;//预测角度

    //时间
    float latency_;
    float fly_t_;
    float react_t_;
    double time_last_ = 0;
    EigenKalmanFilter omega_kf_ = EigenKalmanFilter(3, 2, 1);

    //标志
    bool target_;
    bool reFresh_;

    //接受的消息
    cv::Point2f center_pts_;
    std::vector<cv::Point2f> energy_pts_;
    Eigen::Vector3f ypd_get_;
    float v_;

    rclcpp::Logger logger_ = rclcpp::get_logger("Energy Predictor");
};


} // namespace helios_cv