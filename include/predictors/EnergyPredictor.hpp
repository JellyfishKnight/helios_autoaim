// created by liuhan on 2023/9/15
// Submodule of HeliosRobotSystem
// for more see document: https://swjtuhelios.feishu.cn/docx/MfCsdfRxkoYk3oxWaazcfUpTnih?from=from_copylink
#pragma once

// ros
#include "rclcpp/rclcpp.hpp"
#include "tf2/convert.h"
#include "geometry_msgs/msg/transform_stamped.hpp"
#include "tf2_ros/buffer.h"
// custom
#include "BasePredictor.hpp"
#include "LeastSquares.hpp"
#include "KalmanFilter.hpp"
#include "PnPSolver.hpp"
#include "Omega.hpp"
// opencv
#include"opencv2/imgproc.hpp"
#include"opencv2/highgui.hpp"
#include"opencv2/core.hpp"
// eigen 
#include"eigen3/Eigen/Core"
#include"eigen3/Eigen/Dense"
#include"eigen3/Eigen/Geometry"
// ceres-solver
#include"ceres/ceres.h"
#include"ceres/problem.h"

#define INIT 1
#define STANDBY 2
#define ESTIMATE 3
#define PREDICT 4
#define BIG_ENERGY 2
#define SMALL_ENRGY 1
#define AUTOAIM 0

// auto generated by ros2 generate_parameter_library
// https://github.com/PickNikRobotics/generate_parameter_library
#include "helios_autoaim_parameters.hpp"
#include <opencv2/core/types.hpp>

namespace helios_cv {

class EnergyPredictor : public BasePredictor {
public:
    EnergyPredictor(helios_autoaim::Params::Predictor::EnergyPredictor predictor_params);
    
    void set_cam_info(sensor_msgs::msg::CameraInfo::SharedPtr cam_info) override;

    void init_predictor(helios_autoaim::Params::Predictor predictor_param, tf2_ros::Buffer::SharedPtr tf_buffer) override;

    helios_rs_interfaces::msg::Target predict_target(helios_rs_interfaces::msg::Armors armors, const rclcpp::Time& now) override;

    void set_params(helios_autoaim::Params::Predictor predictor_params) override;

    std::vector<double> get_state() const override;
    void energy_refresh();
private:
    helios_autoaim::Params::Predictor::EnergyPredictor predictor_params_;
    tf2_ros::Buffer::SharedPtr tf_buffer_;


    /**
     * @brief 预测主函数
    */
    void energy_predict(uint8_t mode, std::vestor<cv::Point2f> &energy_points, cv::Point2f &center);


    /**
     * @brief 滤波器滤波角速度
    */
    void FilterOmega();

    /**
     * @brief 有限状态机
    */
    bool EnergyStateSwitch();


    /**
     * @brief 计算预测后的点
    */
    cv::Point2f calPredict(cv::Point2f &p, cv::Point2f &center, float theta)const;

    void getPredictRect(cv::Point2f &center, std::vector<cv::Point2f> &pts, float theta);

    //转速相关
    uint8_t mode_;
    uint8_t circle_mode_;
    Omega omega_;
    float total_theta_;
    std::vector<float> filter_omega_;

    int ceres_cnt_;

    cv::Point2f last_point_;//上一个装甲板中心点
    cv::Point2f predict_center_;//预测的中心点
    cv::Point2f predict_point_;//预测的装甲板四个点
    float predict_rad_ ;//预测角度

    //时间
    float latency_;
    float fly_t_;
    float react_t_;
    double time_last_ = 0;
    EigenKalmanFilter omega_kf_ = EigenKalmanFilter(3, 2, 1);

    //标志
    bool target_;
    bool isSolve_;
    bool reFresh_;

    //接受的消息
    cv::Point2f center_pts_;
    std::vector<cv::Point2f> energy_pts_;
    Eigen::Vector3f ypd_get_;
    float v_;


};


} // namespace helios_cv