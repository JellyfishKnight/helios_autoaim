// created by liuhan on 2023/9/15
// Submodule of HeliosRobotSystem
// for more see document: https://swjtuhelios.feishu.cn/docx/MfCsdfRxkoYk3oxWaazcfUpTnih?from=from_copylink
#pragma once

#include "BasePredictor.hpp"
#include "ExtendedKalmanFilter.hpp"
#include "Armor.hpp"

#include <Eigen/src/Core/Matrix.h>
#include <geometry_msgs/msg/detail/quaternion__struct.hpp>
#include <helios_rs_interfaces/msg/detail/armor__struct.hpp>
#include <helios_rs_interfaces/msg/detail/armors__struct.hpp>
#include <memory>
#include <opencv2/core.hpp>

#include <Eigen/Core>
#include <Eigen/Dense>
#include <rclcpp/logger.hpp>
#include <tf2_ros/buffer.h>
// auto generated by ros2 generate_parameter_library
// https://github.com/PickNikRobotics/generate_parameter_library
#include "helios_autoaim_parameters.hpp"

namespace helios_cv {

typedef enum {LOST, TEMP_LOST, TRACKING, DETECTING} TrakerState;
typedef enum {BALANCE, OUTPOST, NORMAL} TargetType;

class ArmorPredictor : public BasePredictor {
public:
    ArmorPredictor(helios_autoaim::Params::Predictor::ArmorPredictor predictor_params);

    void set_cam_info(sensor_msgs::msg::CameraInfo::SharedPtr cam_info) override;

    void init_predictor(helios_autoaim::Params::Predictor predictor_param, tf2_ros::Buffer::SharedPtr tf_buffer) override;

    helios_rs_interfaces::msg::Target predict_target(helios_rs_interfaces::msg::Armors armors, const rclcpp::Time& now) override;

    void set_params(helios_autoaim::Params::Predictor predictor_params) override;

    std::vector<double> get_state() const override;
private:
    /**
     * @brief 
     * 
     * @param armors 
     */
    void armor_predict(helios_rs_interfaces::msg::Armors armors);

    helios_autoaim::Params::Predictor::ArmorPredictor params_;

    std::shared_ptr<tf2_ros::Buffer> tf2_buffer_;

    // State Machine
    int find_state_;
    int lost_cnt_ = 0;
    int detect_cnt_ = 0;

    double time_predictor_start_;
    //
    uint8_t car_name_;
    //
    std::string tracking_number_;

    // 识别到的目标点
    cv::Point2f target_point;
    // 上一次的装甲板状态
    double last_yaw_ = 0;
    double last_y_ = 0;
    double last_r_ = 0;
    double target_yaw_ = 0;
    std::string armor_type_;
    TargetType target_type_;
    helios_rs_interfaces::msg::Armor last_armor_;

    helios_rs_interfaces::msg::Armor tracking_armor_;
    // 目标车辆状态
    Eigen::VectorXd target_state_;
    // 车中心点
    Eigen::Vector3d car_center_ = {0, 0, 0};
    //目标xyz
    Eigen::Vector3d target_xyz_ = {0, 0, 0};
    //本次预测xyz
    Eigen::Vector3d predict_xyz_ = {0, 0, 0};
    //上一次的目标xyz
    Eigen::Vector3d last_xyz_ = {0, 0, 0};
    //上一次预测的xyz
    Eigen::Vector3d last_predict_xyz_ = {0, 0, 0};
    // kalman utilities
    double dz_;
    double dt_ = 0.008f;
    double s2qxyz_;
    double s2qyaw_;
    double s2qr_;
    double r_xyz_factor_;
    double r_yaw_;
    ExtendedKalmanFilter ekf_;

    void update_target_type(const helios_rs_interfaces::msg::Armor& armor);

    double orientation2yaw(const geometry_msgs::msg::Quaternion& orientation);

    void reset_kalman();

    void armor_jump(const helios_rs_interfaces::msg::Armor tracking_armor);

    Eigen::Vector3d state2position(const Eigen::VectorXd& state);

    // Logger
    rclcpp::Logger logger_ = rclcpp::get_logger("ArmorPredictor");
};

} // namespace helios_cv