// created by liuhan on 2023/9/15
// Submodule of HeliosRobotSystem
// for more see document: https://swjtuhelios.feishu.cn/docx/MfCsdfRxkoYk3oxWaazcfUpTnih?from=from_copylink
#pragma once

// ros
#include "rclcpp/rclcpp.hpp"
#include "tf2/convert.h"
#include "geometry_msgs/msg/transform_stamped.hpp"
#include "tf2_ros/buffer.h"
// custom
#include "BasePredictor.hpp"
#include "CeresSolver.hpp"
#include "KalmanFilter.hpp"
#include "PnPSolver.hpp"
// opencv
#include"opencv2/imgproc.hpp"
#include"opencv2/highgui.hpp"
#include"opencv2/core.hpp"
// eigen 
#include"eigen3/Eigen/Core"
#include"eigen3/Eigen/Dense"
#include"eigen3/Eigen/Geometry"
// ceres-solver
#include"ceres/ceres.h"
#include"ceres/problem.h"

#define INIT 1
#define STANDBY 2
#define ESTIMATE 3
#define PREDICT 4

// auto generated by ros2 generate_parameter_library
// https://github.com/PickNikRobotics/generate_parameter_library
#include "helios_autoaim_parameters.hpp"
#include <opencv2/core/types.hpp>

namespace helios_cv {

class EnergyPredictor : public BasePredictor {
public:
    EnergyPredictor(helios_autoaim::Params::Predictor::EnergyPredictor predictor_params);
    
    void set_cam_info(sensor_msgs::msg::CameraInfo::SharedPtr cam_info) override;

    void init_predictor(helios_autoaim::Params::Predictor predictor_param, tf2_ros::Buffer::SharedPtr tf_buffer) override;

    helios_rs_interfaces::msg::Target predict_target(helios_rs_interfaces::msg::Armors armors, const rclcpp::Time& now) override;

    void set_params(helios_autoaim::Params::Predictor predictor_params) override;

    std::vector<double> get_state() const override;
private:
    helios_autoaim::Params::Predictor::EnergyPredictor predictor_params_;
    tf2_ros::Buffer::SharedPtr tf_buffer_;
    // cam info and pnp solver
    std::shared_ptr<sensor_msgs::msg::CameraInfo> cam_info_;
    cv::Point2f cam_center_;
    std::shared_ptr<PnPSolver> pnp_solver_;

    void EnergyRefresh();

    void ArmorPredictor(uint8_t mode, std::vector<cv::Point2f> &target_pts, cv::Point2f &center, 
                            const Eigen::Vector3f &gimbal_ypd, float v_, float t_stamp);

    inline bool CheckBulletVelocity(float v_);

    inline float average(const float *x, int len);

    float calOmegaNstep(int step, float& total_theta);

    /**
    * @brief float转int 四舍五入
    */
    inline int round2int(float f);

    inline void JudgeFanRotation();

    inline void FilterOmega(const float &dt);
    /**
    * @brief 有限状态机
    */
    bool EnergyStateSwitch();

    bool FindWavePeak();

    inline Eigen::MatrixXd LeastSquare(std::vector<float>x, std::vector<float>y, int N);

    void estimateParam(std::vector<double>&omega, std::vector<float>&t_);
    /**
     * @brief 通过官方给的大能量机关运动的公式来求角速度
     * 
     */
    inline float IdealOmega(float & t_);
    /**
     * @brief 对角速度积分求解提前量
     */
    float IdealRad(float t1, float t2);
    /**
     * @brief 转换成旋转矩阵来求预测点的坐标
     */
    cv::Point2f calPredict(cv::Point2f &p, cv::Point2f &center, float theta) const;
    /**
     * @brief 对四个点都求，求解出整个预测后的矩形
     */
    void getPredictRect(cv::Point2f &center, std::vector<cv::Point2f>&pts, float theta);
    /**
    * @brief 初始化卡尔曼滤波的参数
    */
    void initFanRotateKalman();

    // void energy_predict_callback(const energy_interfaces::msg::Pts coordinate);

    // void energy_img_callback(const sensor_msgs::msg::Image::SharedPtr img_msg);

    // void setTarget(const energy_interfaces::msg::Pts coordinate);
    //inline void setPredict();

    // void pub_image(Mat &src);

    //void SerialCallBack(energy_interfaces::msg::Receive::SharedPtr receive_msg_ptr);
    void Set_problem_parameter();

    // void ceres_answer_callback(const energy_interfaces::msg::Omega answer);
    cv::Point2f pts;    
    cv::Point2f center_pre;
    std::vector<cv::Point2f> target_pts_pre;
    double time_pre = 0;
    Eigen::Vector3f ypd;
    float v=27;
    cv::Mat send_img;//接收到的图像
    double time_last=0, time_now;
    bool target = false;//是否有目标
    int ceres_cnt=1;
    float pub_omega;
    float pub_time;
    bool isSolve = false;//use ceres or not
    bool refresh = false;
    //各种补偿
    Eigen::Vector3f delta_ypd = {0, 0, 0};
    Eigen::Vector3f predict_ypd = {0, 0, 0};
    Eigen::Vector3f predict_xyz = {0, 0, 0};
    float fly_t = 0.2;//子弹飞行时长
    Eigen::Vector3f back_ypd{0,0,0};//发给电控的补偿
    Eigen::Vector3f energy_offset = {0, 0, 0};//打符转用补偿
    float react_t = 0.15;//电机响应时间
    double time_start = 0;
    double time_fin = 0;
    int a = 0;

    cv::Point image_center;
    uint8_t mode=2;//大符小符
    std::vector<cv::Point2f> target_pts;//装甲板特征点
    cv::Point2f center;//能量机关中点
    Eigen::Vector3f gimbal_ypd;//云台陀螺仪角度
    //float v_;//弹速
    //float t_stamp;//当次时间
    std::vector<float> t_list, time_series;

    float v_vec[4]{};
    int v_vec_pointer = 1;
    float average_v_bullet=27;
    cv::Point2f last_point;//上个目标点
    float current_theta = 0;//当前角度
    float current_omega = 0;//当前角速度
    std::vector<float> angle;//以前的角度，角速度
    long unsigned int differ_step = 4;
    float predict_rad = 0;//预测的弧度角
    float total_theta = 0;
    bool omega_kf_flag=false;//用不用卡尔曼插值
    EigenKalmanFilter omega_kf = EigenKalmanFilter(3, 2, 1);
    int clockwise_cnt = 0;
    int energy_rotation_direction = 1;//1顺时针 -1逆时针
    std::vector<double> filter_omega;
    float dt_ = 0.012;
    u_int8_t circle_mode = INIT;
    int fit_cnt=0;
    float max_omega = 0, min_omega = 5;
    int change_cnt;
    double phi_ = CV_2PI/2;
    double w_=1.942;//1.884~2.0
    double a_ = 0.9125;//0.78~1.045
    int st_ = 15;

    ceres::Problem problem;
    float latency = 0.6;//预测时长
    cv::Point2f predict_point;
    std::vector<cv::Point2f> predict_pts;
};


} // namespace helios_cv